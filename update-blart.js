const fs = require('fs');
const path = require('path');

const files = {"src/lib/generate.ts":"import { supabaseAdmin } from './supabase';\nimport type { ArtStyle } from './supabase';\n\n// --- Google Gemini (Nano Banana) Image Generation ---\n\nconst GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent';\n\ninterface GenerationRequest {\n  style_id: string;\n  style_name: string;\n  prompt_prefix: string;\n  custom_prompt?: string;\n  orientation?: 'portrait' | 'landscape' | 'square';\n  reference_notes?: string;\n  reference_images?: string[]; // URLs to inspiration/reference images\n}\n\ninterface GenerationResult {\n  success: boolean;\n  artwork_id?: string;\n  title?: string;\n  slug?: string;\n  error?: string;\n}\n\n// Style-specific prompt enhancers for richer, more varied results\nconst STYLE_ENHANCERS: Record<string, string[]> = {\n  abstract: [\n    'bold color fields and organic shapes',\n    'layered textures with dripping paint effects',\n    'geometric fragments dissolving into chaos',\n    'vibrant acrylic splashes on raw canvas',\n    'meditative color gradients with subtle texture',\n  ],\n  geometric: [\n    'precise tessellations in warm earth tones',\n    'overlapping translucent polygons',\n    'isometric impossible architecture',\n    'sacred geometry with gold leaf accents',\n    'minimalist line compositions with negative space',\n  ],\n  landscapes: [\n    'misty mountain valley at golden hour',\n    'vast desert dunes under starlight',\n    'tropical coast with turquoise water',\n    'snow-covered forest in soft morning light',\n    'rolling hills with dramatic storm clouds',\n  ],\n  botanical: [\n    'oversized tropical leaves in close-up detail',\n    'delicate wildflower arrangement on dark background',\n    'lush monstera and palm fronds',\n    'dried flower still life in muted palette',\n    'intricate fern patterns with dew drops',\n  ],\n  portraits: [\n    'ethereal figure emerging from abstract color',\n    'silhouette with double exposure landscape',\n    'contemporary portrait with bold color blocking',\n    'dreamlike face composed of natural elements',\n    'fragmented figure in cubist style',\n  ],\n  celestial: [\n    'deep space nebula in vivid ultraviolet',\n    'ringed planet rising over alien terrain',\n    'cosmic dust clouds in gold and teal',\n    'star field with bioluminescent auroras',\n    'eclipse casting light through crystalline structures',\n  ],\n  'ocean-water': [\n    'deep underwater bioluminescence',\n    'crashing wave frozen in crystal detail',\n    'abstract ocean currents in blue and silver',\n    'coral reef teeming with color',\n    'calm tide pool reflections at sunset',\n  ],\n  minimalist: [\n    'single line drawing on textured paper',\n    'two-tone composition with subtle gradient',\n    'negative space study with one focal point',\n    'simple circle and shadow on warm background',\n    'thin horizontal bands in muted palette',\n  ],\n  texture: [\n    'cracked earth with golden veins',\n    'weathered wood grain in extreme close-up',\n    'marble surface with dramatic veining',\n    'rust and patina on aged metal',\n    'layered paper torn to reveal colors beneath',\n  ],\n  surreal: [\n    'melting clocks in a desert landscape',\n    'floating islands connected by waterfalls',\n    'rooms defying gravity with impossible stairs',\n    'objects scaled absurdly large in normal settings',\n    'dreamscape merging ocean floor with sky',\n  ],\n};\n\n// Title generation themes per style\nconst TITLE_THEMES: Record<string, string[]> = {\n  abstract: ['Resonance', 'Convergence', 'Pulse', 'Drift', 'Fracture', 'Bloom', 'Threshold', 'Echo', 'Flux', 'Veil'],\n  geometric: ['Lattice', 'Vertex', 'Prism', 'Tessellation', 'Axis', 'Meridian', 'Grid', 'Facet', 'Vector', 'Form'],\n  landscapes: ['Horizon', 'Valley', 'Ridge', 'Stillness', 'Passage', 'Clearing', 'Solitude', 'Expanse', 'Dawn', 'Dusk'],\n  botanical: ['Petal', 'Root', 'Canopy', 'Bloom', 'Tendril', 'Spore', 'Frond', 'Seed', 'Thorn', 'Moss'],\n  portraits: ['Gaze', 'Presence', 'Shadow Self', 'Inner Light', 'Fragment', 'Reverie', 'Essence', 'Visage', 'Aura', 'Mask'],\n  celestial: ['Nova', 'Orbit', 'Eclipse', 'Nebula', 'Void', 'Astral', 'Corona', 'Zenith', 'Solstice', 'Pulsar'],\n  'ocean-water': ['Tide', 'Depth', 'Current', 'Undertow', 'Swell', 'Reef', 'Abyss', 'Surface', 'Shimmer', 'Riptide'],\n  minimalist: ['Silence', 'Breath', 'Pause', 'Interval', 'Space', 'Line', 'Rest', 'Void', 'Calm', 'Still'],\n  texture: ['Grain', 'Patina', 'Layer', 'Surface', 'Weave', 'Erosion', 'Sediment', 'Fiber', 'Stratum', 'Crust'],\n  surreal: ['Paradox', 'Liminal', 'Threshold', 'Mirage', 'Anomaly', 'Reverie', 'Alchemy', 'Chimera', 'Enigma', 'Portal'],\n};\n\nfunction pickRandom<T>(arr: T[]): T {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nfunction generateTitle(styleSlug: string): string {\n  const themes = TITLE_THEMES[styleSlug] || TITLE_THEMES.abstract;\n  const base = pickRandom(themes);\n  const suffixes = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'No. 1', 'No. 2', 'No. 3', 'No. 4', 'No. 5', 'in Blue', 'in Gold', 'in Shadow', 'at Dawn', 'at Dusk', 'Ascending', 'Descending', 'Unfurling', 'Dissolving', 'Emerging'];\n  if (Math.random() > 0.4) {\n    return `${base} ${pickRandom(suffixes)}`;\n  }\n  return base;\n}\n\nfunction generateDescription(styleSlug: string, title: string): string {\n  const descriptions: Record<string, string[]> = {\n    abstract: [\n      `A study in form and colour that invites contemplation.`,\n      `Bold gestural marks create a dialogue between chaos and order.`,\n      `Layers of pigment build a rich, textural surface that rewards close viewing.`,\n    ],\n    geometric: [\n      `Precise mathematical forms create a harmonious visual rhythm.`,\n      `Clean lines and careful proportions produce a meditative composition.`,\n      `An exploration of symmetry and balance through geometric abstraction.`,\n    ],\n    landscapes: [\n      `A dreamlike vista that captures the essence of untouched wilderness.`,\n      `Light and atmosphere converge in this sweeping natural panorama.`,\n      `An AI interpretation of nature's grandeur, both familiar and otherworldly.`,\n    ],\n    botanical: [\n      `Intricate organic forms reveal the hidden beauty of the natural world.`,\n      `A celebration of botanical elegance rendered in vivid detail.`,\n      `Nature's patterns and textures take centre stage in this intimate study.`,\n    ],\n    portraits: [\n      `A contemporary figure study that blurs the line between identity and abstraction.`,\n      `Human presence emerges from and dissolves into the surrounding composition.`,\n      `An exploration of the self through the lens of algorithmic creativity.`,\n    ],\n    celestial: [\n      `Cosmic phenomena rendered with otherworldly beauty and scale.`,\n      `The vastness of space distilled into a mesmerising visual experience.`,\n      `Stellar formations and celestial light create an immersive cosmic portrait.`,\n    ],\n    'ocean-water': [\n      `The fluid dynamics of water captured in a single transcendent moment.`,\n      `Deep marine blues and aquatic light create an immersive underwater world.`,\n      `Ocean energy and tranquility coexist in this aquatic composition.`,\n    ],\n    minimalist: [\n      `Restrained elegance â€” every element exists with deliberate purpose.`,\n      `A meditation on negative space and the beauty of simplicity.`,\n      `Stripped to its essence, the composition speaks through what it leaves out.`,\n    ],\n    texture: [\n      `Surface, material, and light interact to create a tactile visual experience.`,\n      `Macro-scale textures reveal hidden landscapes within everyday materials.`,\n      `An intimate exploration of surface and substance.`,\n    ],\n    surreal: [\n      `Reality bends and transforms in this dreamlike visual narrative.`,\n      `Familiar elements are reimagined in impossible, captivating arrangements.`,\n      `A window into a world where the laws of physics are merely suggestions.`,\n    ],\n  };\n  const pool = descriptions[styleSlug] || descriptions.abstract;\n  return pickRandom(pool);\n}\n\nfunction generateTags(styleSlug: string): string[] {\n  const baseTags = ['ai-art', 'digital-art', 'wall-art', 'print'];\n  const styleTags: Record<string, string[]> = {\n    abstract: ['abstract', 'contemporary', 'modern-art', 'color-field', 'expressionism'],\n    geometric: ['geometric', 'pattern', 'symmetry', 'mathematical', 'modern'],\n    landscapes: ['landscape', 'nature', 'scenic', 'wilderness', 'environment'],\n    botanical: ['botanical', 'plants', 'nature', 'floral', 'organic'],\n    portraits: ['portrait', 'figure', 'human', 'face', 'identity'],\n    celestial: ['space', 'cosmic', 'stars', 'universe', 'astronomy'],\n    'ocean-water': ['ocean', 'water', 'marine', 'aquatic', 'sea'],\n    minimalist: ['minimal', 'clean', 'simple', 'modern', 'zen'],\n    texture: ['texture', 'material', 'surface', 'macro', 'detail'],\n    surreal: ['surreal', 'dreamlike', 'fantasy', 'imagination', 'otherworldly'],\n  };\n  const extras = styleTags[styleSlug] || styleTags.abstract;\n  const picked = extras.sort(() => Math.random() - 0.5).slice(0, 2 + Math.floor(Math.random() * 2));\n  return [...baseTags, ...picked];\n}\n\nfunction generateColors(styleSlug: string): string[] {\n  const palettes: Record<string, string[][]> = {\n    abstract: [['#E63946', '#F1FAEE', '#457B9D', '#1D3557'], ['#FF6B6B', '#FEC89A', '#B5838D', '#6D6875'], ['#264653', '#2A9D8F', '#E9C46A', '#F4A261']],\n    geometric: [['#003049', '#D62828', '#F77F00', '#FCBF49'], ['#2B2D42', '#8D99AE', '#EDF2F4', '#EF233C'], ['#606C38', '#283618', '#FEFAE0', '#DDA15E']],\n    landscapes: [['#606C38', '#283618', '#FEFAE0', '#DDA15E'], ['#0077B6', '#00B4D8', '#90E0EF', '#CAF0F8'], ['#5F0F40', '#9A031E', '#FB8B24', '#E36414']],\n    botanical: [['#386641', '#6A994E', '#A7C957', '#F2E8CF'], ['#3D405B', '#E07A5F', '#F4F1DE', '#81B29A'], ['#2D6A4F', '#40916C', '#52B788', '#B7E4C7']],\n    portraits: [['#353535', '#3C6E71', '#FFFFFF', '#D9D9D9'], ['#6B2737', '#C97C5D', '#E8D6CB', '#B7B7A4'], ['#0D1B2A', '#1B263B', '#415A77', '#778DA9']],\n    celestial: [['#03071E', '#370617', '#6A040F', '#9D0208'], ['#10002B', '#240046', '#3C096C', '#7B2CBF'], ['#0D1B2A', '#1B263B', '#415A77', '#E0E1DD']],\n    'ocean-water': [['#03045E', '#0077B6', '#00B4D8', '#90E0EF'], ['#005F73', '#0A9396', '#94D2BD', '#E9D8A6'], ['#184E77', '#1E6091', '#1A759F', '#76C893']],\n    minimalist: [['#F5F5F5', '#E0E0E0', '#333333', '#FFFFFF'], ['#FAF9F6', '#C4A77D', '#000000', '#F0EAD6'], ['#FEFEFE', '#9B9B9B', '#2C2C2C', '#F5F5F0']],\n    texture: [['#A68A64', '#936639', '#7F5539', '#582F0E'], ['#D5C6B0', '#B7B09C', '#8C8474', '#5E574D'], ['#DEB887', '#D2B48C', '#BC8F8F', '#8B7355']],\n    surreal: [['#FF006E', '#8338EC', '#3A86FF', '#FFBE0B'], ['#7400B8', '#6930C3', '#5390D9', '#48BFE3'], ['#F72585', '#B5179E', '#7209B7', '#560BAD']],\n  };\n  const options = palettes[styleSlug] || palettes.abstract;\n  return pickRandom(options);\n}\n\n// Fetch a reference image URL and convert to base64\nasync function fetchImageAsBase64(url: string): Promise<{ data: string; mimeType: string } | null> {\n  try {\n    const response = await fetch(url);\n    if (!response.ok) return null;\n    const contentType = response.headers.get('content-type') || 'image/png';\n    const buffer = await response.arrayBuffer();\n    const base64 = Buffer.from(buffer).toString('base64');\n    return { data: base64, mimeType: contentType };\n  } catch {\n    return null;\n  }\n}\n\n// Build the image generation prompt for Gemini\nfunction buildGenerationPrompt(req: GenerationRequest): string {\n  const styleSlug = req.style_name.toLowerCase().replace(/[^a-z-]/g, '').replace(/\\s+/g, '-');\n  const enhancers = STYLE_ENHANCERS[styleSlug] || STYLE_ENHANCERS.abstract;\n  const enhancer = pickRandom(enhancers);\n\n  const orientationGuide = {\n    portrait: 'vertical composition, taller than wide, portrait orientation, aspect ratio 2:3',\n    landscape: 'horizontal composition, wider than tall, landscape orientation, aspect ratio 3:2',\n    square: 'square composition, equal width and height, aspect ratio 1:1',\n  };\n\n  const parts = [\n    'Generate an original fine art image.',\n    req.prompt_prefix,\n    enhancer,\n    req.custom_prompt || '',\n    orientationGuide[req.orientation || 'portrait'],\n    req.reference_notes || '',\n    'Fine art quality, suitable for large format printing. High resolution, rich detail, museum-worthy. No text, watermarks, signatures, or borders.',\n  ];\n\n  if (req.reference_images && req.reference_images.length > 0) {\n    parts.push('Use the provided reference images as style and mood inspiration. Create a new original artwork inspired by the aesthetic qualities shown.');\n  }\n\n  return parts.filter(Boolean).join('. ');\n}\n\n// Generate a single artwork using Google Gemini (Nano Banana)\nexport async function generateArtwork(\n  styleId: string,\n  options: {\n    customPrompt?: string;\n    orientation?: 'portrait' | 'landscape' | 'square';\n    referenceNotes?: string;\n    autoPublish?: boolean;\n  } = {}\n): Promise<GenerationResult> {\n  try {\n    const apiKey = process.env.GOOGLE_API_KEY;\n    if (!apiKey) {\n      return { success: false, error: 'GOOGLE_API_KEY environment variable not set' };\n    }\n\n    // Fetch the style\n    const { data: style, error: styleError } = await supabaseAdmin\n      .from('art_styles')\n      .select('*')\n      .eq('id', styleId)\n      .single();\n\n    if (styleError || !style) {\n      return { success: false, error: `Style not found: ${styleId}` };\n    }\n\n    const styleSlug = style.slug;\n    const orientation = options.orientation || pickRandom(['portrait', 'landscape', 'square'] as const);\n\n    // Get reference images from the style\n    const referenceImageUrls: string[] = style.reference_images || [];\n\n    // Build the prompt\n    const prompt = buildGenerationPrompt({\n      style_id: styleId,\n      style_name: style.name,\n      prompt_prefix: style.prompt_prefix || `Create a ${style.name.toLowerCase()} artwork`,\n      custom_prompt: options.customPrompt,\n      orientation,\n      reference_notes: options.referenceNotes,\n      reference_images: referenceImageUrls,\n    });\n\n    // Build the request parts array\n    const parts: any[] = [{ text: prompt }];\n\n    // Add reference images as inline data if available (up to 3)\n    for (const imgUrl of referenceImageUrls.slice(0, 3)) {\n      const imgData = await fetchImageAsBase64(imgUrl);\n      if (imgData) {\n        parts.push({\n          inline_data: {\n            mime_type: imgData.mimeType,\n            data: imgData.data,\n          },\n        });\n      }\n    }\n\n    // Call Google Gemini API\n    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        contents: [{ parts }],\n        generationConfig: {\n          responseModalities: ['TEXT', 'IMAGE'],\n        },\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      return { success: false, error: `Gemini API error: ${response.status} - ${errorText}` };\n    }\n\n    const result = await response.json();\n\n    // Extract image from response - Gemini returns parts with inlineData\n    const candidates = result.candidates;\n    if (!candidates || candidates.length === 0) {\n      const blockReason = result.promptFeedback?.blockReason;\n      return { success: false, error: blockReason ? `Generation blocked: ${blockReason}` : 'No candidates in response' };\n    }\n\n    const responseParts = candidates[0].content?.parts || [];\n    const imagePart = responseParts.find((p: any) => p.inlineData);\n\n    if (!imagePart || !imagePart.inlineData) {\n      const textPart = responseParts.find((p: any) => p.text);\n      const debugText = textPart?.text || 'unknown';\n      return { success: false, error: `No image in response. Model said: ${debugText.substring(0, 200)}` };\n    }\n\n    const imageBase64 = imagePart.inlineData.data;\n    const mediaType = imagePart.inlineData.mimeType || 'image/png';\n\n    if (!imageBase64) {\n      return { success: false, error: 'No image data in response' };\n    }\n\n    // Upload to Supabase Storage\n    const timestamp = Date.now();\n    const ext = mediaType.includes('jpeg') || mediaType.includes('jpg') ? 'jpg' : 'png';\n    const fileName = `${styleSlug}/${timestamp}.${ext}`;\n\n    const imageBuffer = Buffer.from(imageBase64, 'base64');\n    const { error: uploadError } = await supabaseAdmin.storage\n      .from('artworks')\n      .upload(fileName, imageBuffer, {\n        contentType: mediaType,\n        upsert: false,\n      });\n\n    if (uploadError) {\n      return { success: false, error: `Upload failed: ${uploadError.message}` };\n    }\n\n    // Get public URL\n    const { data: urlData } = supabaseAdmin.storage\n      .from('artworks')\n      .getPublicUrl(fileName);\n\n    const imageUrl = urlData.publicUrl;\n\n    // Generate metadata\n    const title = generateTitle(styleSlug);\n    const description = generateDescription(styleSlug, title);\n    const tags = generateTags(styleSlug);\n    const colors = generateColors(styleSlug);\n\n    const slug = title\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/(^-|-$)/g, '')\n      + '-' + timestamp.toString(36);\n\n    const status = options.autoPublish ? 'published' : 'review';\n\n    // Insert artwork record\n    const { data: artwork, error: insertError } = await supabaseAdmin\n      .from('artworks')\n      .insert({\n        title,\n        slug,\n        description,\n        image_url: imageUrl,\n        image_4k_url: imageUrl,\n        thumbnail_url: imageUrl,\n        style_id: styleId,\n        tags,\n        colors,\n        orientation,\n        width_px: orientation === 'landscape' ? 3840 : orientation === 'square' ? 3840 : 2560,\n        height_px: orientation === 'landscape' ? 2560 : orientation === 'square' ? 3840 : 3840,\n        generation_prompt: prompt,\n        generation_model: 'gemini-2.5-flash-image',\n        status,\n        published_at: status === 'published' ? new Date().toISOString() : null,\n      })\n      .select()\n      .single();\n\n    if (insertError) {\n      return { success: false, error: `Database insert failed: ${insertError.message}` };\n    }\n\n    return {\n      success: true,\n      artwork_id: artwork.id,\n      title: artwork.title,\n      slug: artwork.slug,\n    };\n  } catch (err: any) {\n    return { success: false, error: err.message || 'Unknown generation error' };\n  }\n}\n\n// Batch generate artworks\nexport async function batchGenerate(\n  count: number,\n  options: {\n    styleId?: string;\n    orientation?: 'portrait' | 'landscape' | 'square';\n    autoPublish?: boolean;\n  } = {}\n): Promise<{ results: GenerationResult[]; summary: { success: number; failed: number } }> {\n  let styleIds: string[] = [];\n\n  if (options.styleId) {\n    styleIds = [options.styleId];\n  } else {\n    const { data: styles } = await supabaseAdmin\n      .from('art_styles')\n      .select('id')\n      .eq('is_active', true);\n    styleIds = (styles || []).map((s: any) => s.id);\n  }\n\n  if (styleIds.length === 0) {\n    return { results: [], summary: { success: 0, failed: 0 } };\n  }\n\n  const results: GenerationResult[] = [];\n  let success = 0;\n  let failed = 0;\n\n  for (let i = 0; i < count; i++) {\n    const styleId = styleIds[i % styleIds.length];\n    const orientation = options.orientation || pickRandom(['portrait', 'landscape', 'square'] as const);\n\n    const result = await generateArtwork(styleId, {\n      orientation,\n      autoPublish: options.autoPublish || false,\n    });\n\n    results.push(result);\n    if (result.success) success++;\n    else failed++;\n\n    // Rate limit: wait between generations\n    if (i < count - 1) {\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n  }\n\n  return { results, summary: { success, failed } };\n}\n\n// Get available styles for generation\nexport async function getGenerationStyles(): Promise<ArtStyle[]> {\n  const { data } = await supabaseAdmin\n    .from('art_styles')\n    .select('*')\n    .eq('is_active', true)\n    .order('sort_order');\n  return data || [];\n}\n","src/app/api/admin/styles/route.ts":"import { NextRequest, NextResponse } from 'next/server';\nimport { supabaseAdmin } from '@/lib/supabase';\n\n// Middleware to check admin auth\nfunction isAuthenticated(request: NextRequest): boolean {\n  const adminSecret = process.env.ADMIN_SECRET;\n  if (!adminSecret) return false;\n\n  const cookie = request.cookies.get('admin_secret')?.value;\n  if (cookie === adminSecret) return true;\n\n  const authHeader = request.headers.get('authorization');\n  if (authHeader === `Bearer ${adminSecret}`) return true;\n\n  return false;\n}\n\n// GET /api/admin/styles - List all styles with reference images\nexport async function GET(request: NextRequest) {\n  if (!isAuthenticated(request)) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  const { data: styles, error } = await supabaseAdmin\n    .from('art_styles')\n    .select('*')\n    .order('sort_order');\n\n  if (error) {\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n\n  return NextResponse.json({ styles });\n}\n\n// PUT /api/admin/styles - Update a style's reference images\nexport async function PUT(request: NextRequest) {\n  if (!isAuthenticated(request)) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  try {\n    const body = await request.json();\n    const { style_id, reference_images } = body;\n\n    if (!style_id) {\n      return NextResponse.json({ error: 'style_id required' }, { status: 400 });\n    }\n\n    const { data, error } = await supabaseAdmin\n      .from('art_styles')\n      .update({ reference_images: reference_images || [] })\n      .eq('id', style_id)\n      .select()\n      .single();\n\n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 500 });\n    }\n\n    return NextResponse.json({ style: data });\n  } catch (err: any) {\n    return NextResponse.json({ error: err.message }, { status: 500 });\n  }\n}\n\n// POST /api/admin/styles - Upload a reference image to a style\nexport async function POST(request: NextRequest) {\n  if (!isAuthenticated(request)) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n\n  try {\n    const formData = await request.formData();\n    const styleId = formData.get('style_id') as string;\n    const file = formData.get('file') as File;\n\n    if (!styleId || !file) {\n      return NextResponse.json({ error: 'style_id and file required' }, { status: 400 });\n    }\n\n    // Upload to Supabase Storage\n    const buffer = Buffer.from(await file.arrayBuffer());\n    const ext = file.type.includes('jpeg') || file.type.includes('jpg') ? 'jpg' : 'png';\n    const fileName = `references/${styleId}/${Date.now()}.${ext}`;\n\n    const { error: uploadError } = await supabaseAdmin.storage\n      .from('artworks')\n      .upload(fileName, buffer, {\n        contentType: file.type,\n        upsert: false,\n      });\n\n    if (uploadError) {\n      return NextResponse.json({ error: uploadError.message }, { status: 500 });\n    }\n\n    // Get public URL\n    const { data: urlData } = supabaseAdmin.storage\n      .from('artworks')\n      .getPublicUrl(fileName);\n\n    const imageUrl = urlData.publicUrl;\n\n    // Append to style's reference_images array\n    const { data: style } = await supabaseAdmin\n      .from('art_styles')\n      .select('reference_images')\n      .eq('id', styleId)\n      .single();\n\n    const currentImages: string[] = style?.reference_images || [];\n    currentImages.push(imageUrl);\n\n    const { data: updated, error: updateError } = await supabaseAdmin\n      .from('art_styles')\n      .update({ reference_images: currentImages })\n      .eq('id', styleId)\n      .select()\n      .single();\n\n    if (updateError) {\n      return NextResponse.json({ error: updateError.message }, { status: 500 });\n    }\n\n    return NextResponse.json({ style: updated, uploaded_url: imageUrl });\n  } catch (err: any) {\n    return NextResponse.json({ error: err.message }, { status: 500 });\n  }\n}\n"};

for (const [filePath, content] of Object.entries(files)) {
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(filePath, content);
  console.log('Written: ' + filePath);
}
console.log('
Done! Now run:
  git add -A && git commit -m "Switch to Gemini Nano Banana image generation" && git push origin main');
